# chopsticks_two_driver
Launch ```roslaunch chopsticks_two_driver chopsticks_two.launch``` to control the real hardware of the chopsticks_two robotic arm. 

The launch file included several things which are mentioned in the comments of the launch file are described in the following table:

|  Point in Code |  Description |
| --------- |:---|
| 1. Load the URDF      |  Loads the URDF description from the description package to the ROS parameter server.|
| 2. rviz | Runs RViz to visualize the arm and let the user control it |
| 3. Load controller settings | Loads the *.yaml* file for the controllers from the config folder of the driver. There also the frequency the whole control loop should run as is defined. |
| 4.  Load hardware_interface | Starts the main node of this package. Detailed description below |
| 5. Load controller manager | Let the controller manager node load the controllers defined in the *chopsticks_two_controllers.yaml* file in the config folder of this package |
| 6. robot_state_publisher | Publishes the current transform ```/tf``` calculated from the ```/joint_states```-topic. |
| 7. planning_context | Load the configuration files for MoveIt! generated by the *moveit_setup_assistant* |
| 8. move_group | Run MoveIt! and make planning and execution of trajectories possible due to the connected RViz GUI |
| 9. rosserial | Connects to the Arduino via rosserial. Find more about that in the Readme of the *chopsticks_two_servo* folder|

### Messages
The *msg* folder contains two custom messages. ```armCmd``` for commanding the arm six angles. And ```chopsticksTwoTelemetry``` for retrieving the current state of the robots joints. Currently only the angle field of both messages is used.

### Implementation
The *chopsticks_two_hw_main* node consists of three files. Currently it also depends on the *ros_control_boilerplate* package. 

The *src/chopsticks_two_hardware_main.cpp* launches the node and sets up the main control loop. 

The *include/chopsticks_two_hardware_interface.h* declares the important functions ```init```, ```read```, ```write``` and ```enforceLimits``` and sets up the subscriber for the telemetry ```telemetry_sub``` and the publisher of the commands ```cmd_pub```. It also declares the callback function for the subscriber ```telemetryCallback```.

The implementation of all of the functions is done in the *src/chopsticks_two_hardware_interface.cpp* file. In the constructor of the ```chopsticks_twoHWInterface``` ```telemetry_sub``` is set to subscribe to the ```/chopsticks_two_telemetry``` topic and ```cmd_pub``` to publish to the ```/armCmd``` topic. If a new message is received on ```chopsticks_two_telemetry```, ```telemetryCallback``` is called. Here the angles from the motors (received from the Arduino) will be saved into the ```joint_position_``` array which is used to broadcast the ```/joint_states``` topic. Currently only the position of the motors is considered. The ```init``` function will initialized a new hardware interface and will start the control loop. Each loop cycle the ```read``` function will be executed which only checks all callbacks. The ```write``` function comes into place, when a new command to the motors should be send. It takes the command from the launched controller and publishes it via its topic to the real hardware (in this case the Arduino). The ```enforceLimits``` function is not used currently.

### ros_control
![Big picture of ROS control, ROSCon 2014](https://static.wixstatic.com/media/407007_42aa84681a074f03975b4923ce8ffbd6~mv2.png/v1/crop/x_0,y_0,w_1025,h_327/fill/w_600,h_190,al_c,q_85,usm_0.66_1.00_0.01,enc_auto/407007_42aa84681a074f03975b4923ce8ffbd6~mv2.png)

On the left side of the image is the *killer_app*. That's just an App which for example uses the MoveIt! API to make something like AR code detection and calculations of where the robot should go to. As 3rd party tool then MoveIt! is used and commands a controller, for example a *JointTrajectoryController* to move the robot. This command is put to the *hardware_interface* which processes it and sends it to the real hardware (for example an Arduino here). The real hardware takes over the control of the motors then.

[Detailed ROS control presentation](https://roscon.ros.org/2014/wp-content/uploads/2014/07/ros_control_an_overview.pdf)

[Detailed Tutorial of ros_control](https://www.rosroboticslearning.com/ros-control)

[An other tutorial about ros_control](https://fjp.at/posts/ros/ros-control/)

